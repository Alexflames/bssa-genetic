\documentclass[bachelor, och, coursework, times]{SCWorks}

\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}
\usepackage[english,russian]{babel}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{listings}
%\usepackage[colorlinks = false]{hyperref}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}
\newcommand{\scale}{0.5}
\newcommand{\boxscale}{0.93}
\newtheorem{lem}{Лемма}

\lstset{
    breaklines=true, 
    language=C, 
    numberstyle=\tiny, 
    numbers=left, 
    columns=flexible,
    keepspaces=false, 
    basicstyle=\small,
}

\begin{document}
% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Эвристический алгоритм поиска центральных вершин графов}

% Курс
\course{3}

% Группа
\group{311}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}

% Фамилия, имя, отчество в родительном падеже
\author{Власова Андрея Александровича}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{к.\,ф.-м.\,н.} %должность, степень, звание
\saname{С.\,В.\,Миронов}

% Год выполнения отчета
\date{2019}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

\intro
В современных компьютерных науках одно из центральных мест занимает математическая модель графа. Графовая модель позволяет описывать целый ряд систем и 
явлений, которые встречаются в различных предметных областях. Изучение структуры того или иного графа, или же выявление его свойств и особенностей может носить невероятную практическую пользу. В связи с этим работы, посвященные этой теме, вызывают наибольший интерес как со стороны исследователей теоретиков, так и со стороны практиков. 

Одной из важных характеристик любого графа можно назвать радиус графа и расположение его центральных вершин. Получив данные параметры, можно судить об общей структуре графа или же о его особенностях. Современные графовые модели могут насчитывать десятки сотен тысяч вершин, поэтому для эффективного решения задач зачастую бывает недостаточно использовать классические алгоритмы, а необходимо реализовать некоторый эвристический подход, одним из которых является генетический алгоритм.

Цель данной работы "--- предложить эффективный алгоритм поиска центральных вершин в графе, в своей основе реализующий концепции генетического алгоритма, который бы позволил решать задачу за приемлемые временные затраты.

Для достижения данной цели были поставлены следующие задачи:
\begin{itemize}
	\item проанализировать и реализовать существующие алгоритмы поиска центральных вершин,
	\item создать генетический алгоритм поиска центральных вершин,
	\item провести сравнение существующих алгоритмов и созданного и выявить преимущества и недостатки последнего. 	
\end{itemize}


\section{Описание задачи}
Формально, рассматриваемую задачу можно описать следующим образом. 
Пусть задан невзвешенный неориентированный граф $G = (V, E)$, где $V$ "--- множество вершин, $E$ "--- множество ребер.

Также задана функция $F: V \mapsto \mathbb{R}$, определенная на множестве вершин и принимающая действительные значения.
Оптимизационная задача заключается в том, чтобы найти минимум данной функции, и соответствующую вершину $v \in V$ такую, 
что $F(v) = \min\limits_{x \, \in \, V} F(x)$.

В данной работе в роли функции $F(v)$ выступает эксцентриситет вершины $e$ "--- максимальное из всех расстояний от вершины до другой вершины.
Найденный минимум функции $F(v)$ будет достигаться на вершинах, которые в теории графов называется центральными, а значение минимального эксцентриситета "--- радиусом графа.
То есть всю задачу можно описать следующей формулой:

\[
	R = \min\limits_{x \, \in \, V} \max\limits_{y \, \in \, V} (d(x, y)),
\]
где $d(x, y)$ "--- расстояние между вершинами $x, y$; $R$ "--- радиус графа.
 
\section {Существующие алгоритмы для решения задачи}
Вследствие естественности описанных характеристик, радиус графа и эксцентриситет вершины являются одними из базовых параметров, которые наиболее часто встречаются в прикладных задачах, либо необходимы при исследовании свойств графа \cite{DIAMETR1}, \cite{SMALL_WORLD}. Этим объясняется довольно большое количество работ, в которых изучается данная задача. Основные популярные методы решения можно разделить на алгоритмы дающих точные решения (или с фиксированным уровнем ошибки) и алгоритмы, внутри которых реализована эвристика, позволяющая резко увеличить скорость выполнения за счет увеличения вероятности найти субоптимальное решение. Как раз к последним можно отнести генетические алгоритмы.

\subsection{Точные алгоритмы}
Одним из очевидных наблюдений в данной задачи является тот факт, что рассматриваемый алгоритм поиска центральных вершин неразрывно связана с проблемой
поиска кротчайших путей между всеми парами вершин. Существующие алгоритмы, можно разделить на два подхода, в первом из которых
граф представляется в виде матрицы смежности и дальнейших вычислениях используется матричное умножение. Другим направлением можно назвать алгоритмы, которые используют в своей работе некоторые оптимизационные идеи для асимптотического улучшения времени работы.

\subsubsection{Тривиальный алгоритм}
Тривиальный алгоритм может быть реализован запуском из каждой вершины графа поиска в ширину, который получит расстояние от текущей вершины до всех остальных. Зная расстояния между всеми парами вершин, не составляет труда найти эксцентриситет вершины и значение радиуса. При этом асимптотическое время работы равно $O(n^2 + nm)$, где $n$ "--- количество вершин, а $m$ "--- количество ребер в графе. Данная оценка при высоком количестве ребер равносильна оценке $O(n^3)$.
 
\subsubsection{Алгоритмы, использующие матричное умножение}
Одним из естественных способов задания неориентированного невзвешенного графа может служить бинарная матрица смежности, в которой единичные элементы описывают ребра, соединяющие вершины в соответствующей строке и столбце. Ввиду этого для поиска кротчайших расстояний между вершинами может быть применен алгоритм, описанный в статье \cite{Seidel}, в основе которого лежит матричное умножение. Алгоритм матричного умножения также имеет время выполнения $O(n^3)$, при этом существуют способы оптимизации, способные улучшить эту оценку до $O(n^w)$, где $w \leq 2.81$ \cite{Strassen1969}.

\subsubsection{Алгоритмы с улучшенной асимптотикой}
В работе \cite{Aingworth} приводится алгоритм, позволяющий найти радиус графа и расстояние между всеми парами вершин. Время работы алгоритма имеет асимптотическое улучшение и равно $O(m\sqrt{n} + n^2)$. Основной идеей данного алгоритма является эвристика разделения вершин на два множества, в одно из которых попадают вершины с высокой степенью, а во второе "--- с низкой. Для первого набора вершин строится доминирующее множество "--- множество вершин графа, такое, что любая вершина вне доминирующего множества смежна хотя бы с одной вершиной из него; из которого запускаются обходы в ширину, подсчитывающие расстояния. Также обходы в ширину запускаются внутри множества вершин с низкой степенью, при этом для этого случая обход проводится не по всем вершинам графа, а лишь по элементам, находящимися внутри данного множества. Такой подход позволяет получить искомый радиус графа или же найти центральные вершины за меньшие временные затраты по сравнению с другими алгоритмами. Данная работа получила дальнейшее развитие в \cite{APSP, Fast_Approximation, Fast_Radius}, где используются различные подходы модернизирующие существующий, позволяющие ускорить алгоритм для некоторых видов графов. 

\subsection{Эвристические алгоритмы}
\subsubsection{Генетический алгоритм}
Впервые идея генетического алгоритма, как метода решения оптимизационных задач, была предложена в работе \cite{Holland}. В основе любого генетического алгоритма лежит процесс моделирования эволюционного развития, который во многом определяется генетическими механизмами в живых организмах и естественным отбором. 

Для каждой рассматриваемой задачи выбирается способ кодирования решения, после чего формируется начальная популяция, состоящая из набора возможных решений, которая будет эволюционировать.
В качестве генетических процессов используется два оператора, которые изменяют текущую популяцию в сторону правильного ответа. 

Первый из этих них "--- оператор скрещивания (кроссинговера). Ему на вход подается два представителя из текущей популяции, после чего с помощью некоторых преобразований формируется некоторая новая особь, которой частично передались свойства двух ее родителей. Данный оператор позволяет переносить некоторые найденные лучшие решения, при этом комбинируя их для возможного последующего улучшения. 

При использовании только такого подхода в качестве решения может найтись некоторое локальное оптимальное значение, которое не будет совпадать с глобальным, поэтому также в работу алгоритма вводится оператор мутации, который некоторым образом с заданной вероятностью изменяет текущую особь, что позволяет расширить круг поиска и не сбиться в локальный экстремум.

Также неотъемлемой частью любого генетического алгоритма является моделирование процесса естественного отбора. С помощью него удается перенести в следующее поколение только особи, которые представляют наилучшее решение, при этом отсеяв худшие. Таким образом в генетическом алгоритме итерационно происходит процесс естественного отбора, скрещивания и мутации. Данный подход основывается на эвристике позаимствованный из наблюдений за живой природой и позволяет эффективно решать оптимизационную задачу в тех случаях, где это не представляется возможным сделать с помощью точных методов.


Для решения рассматриваемой задачи также были созданы различные эвристические алгоритмы. Например, в работе \cite{GA_N4N}, приводится генетический алгоритм, позволяющий решать различного рода задачи из теории графов. 

В основе построения данного алгоритма лежат классические этапы генетического подхода, при этом решение кодируется набором вершин, заданной мощности. В этой же работе рассматривается применение генетического алгоритма для решения целого ряда задач, одна из которых проблема нахождения $k$=центральных вершин, которая заключается в том, что необходимо найти ровно $k$ центральных вершин, сумма эксцентриситетов которых была бы минимальна. Несложно заметить, что задача будет совпадать с проблемой поиска центральной вершины, если в качестве $k$ выбрать 1. 

В описываемом алгоритме оператор скрещивания имеет следующую реализацию. Рассматриваются две особи (два множества), которые должны перейти в следующее поколение. Далее находится разность второго множества с первым, которая называется первым вектором обмена, также находится разность первого со вторым, которая называется вторым вектором обмена, после чего генерируется случайная позиция, относительно которой будет производится скрещивание. После проделанных операций происходит обмен элементами относительно найденной позиции каждого множества с соответствующим ему вектором обмена. За счет такого подхода на каждой итерации алгоритма в множестве, описывающем конкретную особь не существует повторяющихся вершин, при этом размер этого множества остается неизменным.

В качестве оператора мутации используется следующий подход: для каждой вершины находится набор ее соседей, после чего из этого множества случайным образом выбирается 4 вершины, которых нет в множестве особи. Для каждой из четырех вершин находится ее эксцентриситет, 
после чего с вероятностью заданной для оператора мутации вершина"=сосед заменяет вершину в популяции. Данный подход был назван авторами N4N эвристикой, поэтому далее данный алгоритм будет называться <<N4N алгоритм>>. В естественном отборе в качестве целевой функции ставиться значение эксцентриситета вершины. 

Данный подход в реализации генетического алгоритма позволяет решать не только задачу поиска центральных вершин, но и еще ряд проблем связанных с теорией графов, однако ввиду общности способа представления решения и реализации оператора скрещивания может иметь свои недостатки, которые могут проявиться в конкретной задаче.

\section{Описание созданного генетического алгоритма}
Как уже отмечалось ранее оновными этапами любого генетического алгоритма являются процессы кроссинговера, мутации, естественного отбора и проверки критерия останова алгоритма. 
Предлагаемый алгоритм включает в себя все описанные процессы, которые реализованы с учетом рассматриваемой проблемы.

Основную идею алгоритма можно изложить следующим образом:
\begin{enumerate}
	\item на начальном этапе есть некоторое множество вершин, заданных текущей популяцией, при этом искомая центральная вершина (или вершина близкая к центральной) находится на одном из путей между парой вершин в популяции. Текущую популяцию можно представить как некую <<сферу>> (см. рисунок~\ref{pic1}), нарисованную множеством вершин, внутри которой находится искомый ответ;
	
	\item далее, основываясь на идее о том, что искомый ответ лежит на пути между между вершинами популяции, на каждой итерации своеобразная <<сфера>> начинает сжиматься, сужая круг поиска искомой вершины и приводя к сходимости алгоритма (см. рисунок~\ref{pic2});
	
	\item алгоритм может закончить свою работу на итерации, когда расстояние между вершинами не станет равным 0 или 1.
\end{enumerate}

\begin{figure}[!ht]
\centering
\includegraphics[scale = \scale]{pic1.png} 
\caption{\label{pic1} Начальное состояние алгоритма (желтый цвет "--- центральная вершина, зеленый цвет "--- начальная популяция)}
\end{figure}


\begin{figure}[!ht]
\centering
\includegraphics[scale = \scale]{pic2.png} 
\caption{\label{pic2} Сходимость алгоритма (желтый цвет "--- центральная вершина, зеленый цвет "--- начальная популяция)}
\end{figure}

\subsection{Инициализация начальной популяции}
Для старта алгоритма необходимо выбрать начальное множество вершин, которое будет описывать начальную популяцию. 
Учитывая тот факт, что в предложенном алгоритме не учитываются никакие данные о свойствах графа, то начальная популяция генерируется случайным образом с равновероятным выбором вершины.

\subsection{Естественный отбор}
Так как основной целью алгоритма является нахождение вершины с минимальным эксцентриситетом, то в качестве целевой функции как раз и
выступает эта характеристика вершины. Для каждой вершины в популяции находится ее эксцентриситет, так как граф невзвешенный,
то данную процедуру можно выполнить с помощью классического алгоритма обхода в ширину и найти расстояния от вершины до всех остальных (см. рисунок ~\ref{pic5}). При этом приоритет для попадания в следующее поколение отдается вершинам с меньшим эксцентриситетом.

\begin{figure}[!ht]
\centering
\includegraphics[scale = \scale]{pic5.png} 
\caption{\label{pic5} Процесс поиска самой удаленной вершины (желтый цвет "--- центральная вершина, зеленый цвет "--- начальная популяция, красный "--- 
вершины на пути в самые удаленные точки графа)}
\end{figure}

\subsection{Процесс кроссинговера}
Каждая вершина представляет потенциальное решение,  исходя из предположения, что центральные вершины находятся внутри <<сферы>>, определенной существующей 
популяцией, то для улучшения решения случайным образом выбираются две вершины, после чего между ними находится кротчайший путь, из которого в следующее 
поколение добавляется вершина, находящаяся на половине расстояния от выбранных вершин (см. рисунок ~\ref{pic3}). Данная идея позволяет так называемой 
<<сфере>> сжиматься на каждой итерации и уменьшать расстояние между вершинами внутри популяции.

\begin{figure}[!ht]
\centering
\includegraphics[scale = \scale]{pic3.png} 
\caption{\label{pic3} Процесс скрещивания (желтый цвет "--- центральная вершина, зеленый цвет "--- начальная популяция, красный "--- кротчайший путь между 
вершинами популяции)}
\end{figure}

\subsection{Процесс мутации}
Для того, чтобы алгоритм в процессе своей работы не сходился к некоторым локальным решениям, а имел возможность рассмотреть новые варианты развития 
популяции, на каждой итерации в рамках процесса мутации у всех вершин в популяции выбирается случайным вершина смежная с данной и с вероятностью, 
заданной, параметром мутации переходит в следующее поколение (см. рисунок ~\ref{pic4}). Данный процесс помогает алгоритму добавлять в новую популяцию 
<<свежие>> вершины, которые могут привести к потенциально лучшему решению.
\begin{figure}[!ht]
\centering
\includegraphics[scale = \scale]{pic4.png} 
\caption{\label{pic4} Процесс мутации (желтый цвет "--- центральная вершина, зеленый цвет "--- начальная популяция, красный "--- соседние вершины одной из 
вершин в популяции)}
\end{figure}


\section{Реализация алгоритма}
Для построения предложенного алгоритма был выбран язык программирования C++.
В качестве среды разработки, из которой производился запуск проекта была использована \verb|Visual Studio 2017|, которая была установлена на персональном компьютере с процессором \verb|AMD A8-7410| c тактовой частотой \verb|2.20 GHz| и оперативной памятью объемом \verb|6.0 GB|. 


Из описанных ранее действий, которые происходят внутри генетического 
алгоритма видно, что основным процессом, который необходимо реализовать, является процесс нахождения эксцентриситета. Для более комфортного взаимодействия 
алгоритма с моделью графа был создан класс \verb|Graph|, внутри которого содержится информация о его структуре в виде списка смежности, реализованного с 
помощью вложенных контейнеров \verb|vector| из стандартной библиотеки шаблонов языка C++. С помощью поддержания такой структуры графа появляется 
возможность прямого доступа ко всем соседям любой вершины по ее номеру, при этом нумерация вершин ведется с 0 до $n - 1$. 

Также очевидно, что, так как процесс нахождения эксцентриситета вершины требует больших временных затрат, то внутри класса поддерживается
матрица $n \times n$,
в которую добавляется каждый раз найденный эксцентриситет. Также поддерживается матрица, в которую добавляется каждый кротчайший путь, 
который находится в процессе алгоритма.  
С использованием данного класса реализован, как алгоритм, описанный ранее, так и ряд точных алгоритмов. 

Для генерации тестовых графов использовалась библиотека \verb|NetworkX| языка Python. Тестовые графы хранятся в текстовых файлах, в которых перечислен 
весь список ребер графа. Исходя из этого был написан класс \verb|File|, который позволяет считывать из файла существующий граф.

Полный код проекта приведен в приложении \ref{app1}. 


\section{Модели случайного графа}
Для исследования созданного алгоритма и его сравнения с существующими были выбраны несколько моделей случайных графов, которые в большей степени описывают 
свойства реально существующих графов, встречающихся в прикладных задачах. 

\subsection{Модель случайного графа Эрдеша"=Реньи}
Данная модель представленная в работе \cite{ER} является одной из самых простых и базовых моделей случайного графа. Изначально для создания графа задаются 
два параметра $n$ "--- число вершин в графе и $p$ "--- вероятность проведения ребра. 
Далее для построения графа рассматриваются все пары вершин, и между ними проводится неориентированное ребро с вероятностью $p$. В данной модели ввиду ее 
простоты формулировки довольно легко выводятся формулы, зависящие от параметра $p$ и $n$, которые описывают основные характеристики графов, такие как 
связность, размер максимальной клики, распределение степени вершин и т.д. Поэтому если удается установить, что граф в рассматриваемой задаче близок по 
свойствам с графом Эрдеша"=Реньи, то можно без труда получить много информации об изучаемом графе.

\subsection{Модель случайного графа Барабаши"=Альберт}
Данная модель случайного графа была предложена в работе \cite{BA}. На данный момент описанная модель позволяет создавать так называемые безмасштабные сети 
"--- графы, в которых распределение степеней подчиняется степенному закону. Исследования данного подхода показали, что графовые модели, которые описывают 
взаимосвязи внутри различных самоорганизующихся систем, совпадают с моделью Барабаши"=Альберта. К таким сетям относятся ряд графов социальных сетей, сеть 
Интернет, ряд графовых моделей в природных сетях. 

В ходе построения случайного графа поддерживаются два основных принципа, которые главным образом характеризуют безмасштабные сети. Первый из них принцип расширения сети, второй "--- предпочтительное прикрепление. Первый принцип описывается тем фактом, что в существующую сеть могут постоянно добавляться новые узлы, при этом не нарушая его свойств из"=за второго принципа. Принцип предпочтительного прикрепления заключается в том, что добавляемый узел случайным образом прикрепляется ребрами к вершинам, которые уже существуют в графе, при этом предпочтение отдается вершинам с большей степенью, формально вероятность проведения ребра к $i$"=му узлу описывается следующий формулой:
\[
	p_i = \frac{k_i}{\sum_j k_j},
\] 
где $k$ "--- степень узла, $j$ пробегает все вершины в графе. 

Для создания графа задаются два параметра $n$ "--- число вершин в создаваемом графе, и $m$ "--- число ребер, которые проводится из каждой новой добавляемой вершины в граф. Алгоритм создания достаточно прост, в качестве начального графа берется связный граф с числом вершин большим или равным $m$, после чего добавляются новые вершины до необходимого количества, при этом каждая новая вершина соединяется с $m$ вершинами случайным образом с вероятностным распределением, описанным формулой выше.

\subsection{Геометрический случайный граф}
Данная модель случайного графа \cite{GEOM} описывает основные свойства, которые возникают в графовых моделях компьютерных сетей и сетей, имеющих явную географическую интерпретацию. Для построения графа выбирается размерность пространства, в котором будет создаваться граф, наиболее часто выбирается двумерное пространство, на котором случайным образом генерируется набор геометрических точек равных по количеству числу узлов в создаваемом графе, после чего для каждой пары точек рассчитывается евклидово расстояние между ними и проводится ребро в том случае, если расстояние меньше параметра $r$, который задается заранее.

Данная модель случайного графа имеет свои отличительные характеристики, которые не совпадают с моделями Эрдеша"=Реньи и Барабаши"=Альберта.


\section{Результаты вычислительных экспериментов}
Для выявления сильных и слабых сторон предложенного алгоритма его сравнение проводилось с рядом точных алгоритмов, а также с алгоритмом <<N4N>>. В качестве тестовых графов были выбраны графовые модели описанные ранее. Для модели Эрдеша"=Реньи в качестве параметра $p$ было выбрано значение 5\%, для модели Барабаши"=Альберта $m = 2$, а для геометрического случайного графа $r = 0.1$. 

Чтобы лучше понять механизм алгоритма, природу его работы и определить оптимальные параметры для его настройки, такие как число итераций, размер популяции вероятность мутации и скрещивания были сделаны пошаговые визуализации каждой итерации алгоритма на случайном геометрическом графе (см. рисунок \ref{pic8}).

\begin{figure}[!ht]
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step1.png} \center{Начальная популяция} \\	
	\end{minipage}
	\hfill
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step3.png} \center{Популяция после двух шагов} \\
	\end{minipage}
	\vfill
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step5.png} \center{Популяция после четырех шагов} \\
	\end{minipage}
	\hfill
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step7.png} \center{Популяция после шести шагов} \\
	\end{minipage}
	\vfill
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step9.png} \center{Популяция после восьми шагов} \\
	\end{minipage}
	\hfill
	\begin{minipage}{0.5\linewidth}
		\includegraphics[width = \linewidth]{step11.png} \center{Популяция после десяти шагов} \\
	\end{minipage}
	\caption{\label{pic8} Шаги работы алгоритма (желтый цвет "--- центральная вершина, красный "--- популяция, темно синий "--- особь, представляющая правильный ответ)}
\end{figure}


Для сравнения по временным результатам были реализованы тривиальный алгоритм и алгоритм с улучшенной асимптотикой. Эти алгоритмы и описанный в данной работе запускались на трех моделях случайных графов, с количеством вершин 500, 1000, 1500, 2000, 2500, 5000. Исходя из практических экспериментов в качестве размера популяции выбрано значение 50, для оператора скрещивания 0.7, для оператора мутации 0.1, кроме этого число итераций ограничено числом 20. Результаты временных измерений приведены на графиках \ref{pic6}. Из полученных результатов видно, что созданный генетический алгоритм дает выигрыш по времени в несколько раз по сравнению с точными алгоритмами. 

\begin{figure}
	\scalebox{\boxscale}{
	\begin{minipage}{0.5\linewidth}
				\centering
				\begin{tikzpicture}
				\begin{axis}[
						legend pos = north west,
						height = \linewidth, 
						width = \linewidth,
						xmin = 500, xmax = 5000,
						ylabel = {Время, сек.},
						xlabel = {Количество вершин},
					]
				\addplot  coordinates {
					(500, 0.302)
					(1000, 1.112)
					(1500, 2.223)
					(2000, 4.518)
					(2500, 8.702)
					(5000, 65.393)
				};
				\addplot  coordinates {
					(500,  0.37)
					(1000, 0.87)
					(1500, 1.25)
					(2000, 1.99)
					(2500, 3.22)
					(5000, 13.64)
				};
				\addplot  coordinates {
					(500, 0.16)
					(1000, 0.60)
					(1500, 1.44)
					(2000, 2.17)
					(2500, 2.68)
					(5000, 8.47)
				};
				\end{axis}
				\end{tikzpicture}
				(\textit{a})
			\end{minipage}
		}
		\hfill
		\scalebox{\boxscale}{
		\begin{minipage}{0.5\linewidth}
			\centering
			\begin{tikzpicture}
				\begin{axis}[
						legend pos = north west,
						height = \linewidth, 
						width = \linewidth,
						xmin = 500, xmax = 5000,
						ylabel = {Время, сек.},
						xlabel = {Количество вершин}
					]
				\addplot  coordinates {
					(500, 0.377)
					(1000, 1.272)
					(1500, 3.392)
					(2000, 6.43)
					(2500, 14.406)
					(5000, 93.67)
				};
				\addplot  coordinates {
					(500, 0.072)
					(1000, 0.564)
					(1500, 1.1328)
					(2000, 1.70)
					(2500, 3.204)
					(5000, 18.456)
				};
				\addplot  coordinates {
					(500, 0.11)
					(1000, 0.38)
					(1500, 0.54)
					(2000, 1.022)
					(2500, 1.64)
					(5000, 4.19)
				};
				\end{axis}
		\end{tikzpicture}
				(\textit{b})
		\end{minipage}
		}
		\vfill
		\scalebox{\boxscale}{
			\begin{minipage}{0.5\linewidth}
					\centering
					\begin{tikzpicture}
					\begin{axis}[
							legend pos = north west,
							height = \linewidth, 
							width = \linewidth,
							xmin = 500, xmax = 5000,
							ylabel = {Время, сек.},
							xlabel = {Количество вершин}
					]
					\addplot  coordinates {
						(500, 0.377)
						(1000, 1.272)
						(1500, 3.392)
						(2000, 6.43)
						(2500, 14.40)
						(5000, 93.67)
					};
					\addplot  coordinates {
						(500, 0.072)
						(1000, 0.564)
						(1500, 1.1328)
						(2000, 1.70)
						(2500, 3.204)
						(5000, 18.456)
					};
					\addplot  coordinates {
						(500, 0.11)
						(1000, 0.38)
						(1500, 0.54)
						(2000, 1.022)
						(2500, 1.64)
						(5000, 4.19)
					};
					\end{axis}
					\end{tikzpicture}
					(\textit{c})
	 		\end{minipage}
 		}
	\caption{\label{pic6} Графики зависимости времени работы от размеров графа (синий цвет "--- тривиальный $O(nm + n^2)$ алгоритм, красный "--- 	алгоритм с улучшенной асимптотикой $O(m\sqrt{n})$, коричневый "--- генетический алгоритм): (\textit{a}) "--- модель Эрдеша"=Реньи $p = 1\%$, (\textit{b}) "--- модель Барабаши"=Альберта $m = 2$, (\textit{c}) "--- геометрический случайный граф $r = 0.1$}
\end{figure}

Также так как эвристический алгоритм не гарантирует получение точного ответа, а допускает некий процент ошибки, то для изучения точности алгоритма были 
проведены тесты позволяющие выявить процент неправильных ответов. Для этого алгоритм запускался на все тех же графах, при этом так как размерности графа, 
позволяют за приемлемые временные затраты с помощью точного алгоритма найти центральные вершины, то зная эту информацию можно говорить о проценте 
неправильных ответов. Для сравнения брался алгоритм <<N4N>>, после чего оба алгоритма запускались 100 раз, что позволило подсчитать процент ошибки. 
Результаты вычислительных экспериментов приведены в таблицах \ref{tab1}, \ref{tab2} и \ref{tab3}. 

\begin{table}[!ht]
\centering
\small
\caption{\label{tab1} Время работы и процент ошибки алгоритмов на случайных геометрических графах}
\begin{tabular}{@{}ccccccc@{}}
\toprule
№                      & \multicolumn{2}{c}{Размер графа}       & \multicolumn{2}{c}{Время, сек.}    & \multicolumn{2}{c}{Ошибка, \%} \\ \midrule
                       & N     & M                            & Созданный алг.   & N4N алг.                    & Созданный алг.           & N4N алг.          \\ \midrule
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{3572}    & 0.11  & \multicolumn{1}{c|}{0.39} & 38.0          & 40.0           \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{14202}   & 0.31  & \multicolumn{1}{c|}{0.77} & 21.0          & 50.0           \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{31861}   & 0.71  & \multicolumn{1}{c|}{1.44} & 13.0          & 62.0           \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{57438}   & 1.20  & \multicolumn{1}{c|}{1.92} & 8.0           & 48.0           \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{90268}   & 1.76  & \multicolumn{1}{c|}{2.68} & 4.0           & 30.0           \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{358553}  & 4.48  & \multicolumn{1}{c|}{8.61} & 0.0           & 0.0            \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{1439255} & 13.54 & \multicolumn{1}{c|}{26.0} & 0.0           & 0.0            \\ \bottomrule
\end{tabular}
\end{table}

\begin{table}[!ht]
\centering
\small
\caption{\label{tab2} Время работы и процент ошибки алгоритмов на модели случайного графа Барабаши"=Альберта}
\begin{tabular}{@{}ccccccc@{}}
\toprule
                      & \multicolumn{2}{c}{Размеры графа}     & \multicolumn{2}{c}{Время, сек.}   & \multicolumn{2}{c}{Ошибка, \%} \\ \midrule
                       & N     & M                          & Созданный алг. & N4N алг.                       & Созданный алг.            & N4N алг.          \\ \midrule
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{996}   & 0.07 & \multicolumn{1}{c|}{0.29} & 16.0           & 0.0          \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{1996}  & 0.18 & \multicolumn{1}{c|}{0.68} & 12.0           & 0.0          \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{2996}  & 0.37 & \multicolumn{1}{c|}{1.24} & 4.0            & 0.0          \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{3996}  & 0.55 & \multicolumn{1}{c|}{1.67} & 1.0            & 0.0          \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{4996}  & 0.69 & \multicolumn{1}{c|}{2.18} & 0.0            & 0.0          \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{9996}  & 1.84 & \multicolumn{1}{c|}{8.28} & 0.0            & 0.0          \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{19996} & 3.90 & \multicolumn{1}{c|}{15.8} & 0.0            & 0.0          \\ \bottomrule
\end{tabular}
\end{table}



\begin{table}[!ht]
\centering
\small
\caption{\label{tab3} Время работы и процент ошибки алгоритмов на модели случайного графа Эрдеша"=Реньи}
\begin{tabular}{ccccccc}
\hline
\multicolumn{1}{l}{}   & \multicolumn{2}{c}{Размеры графа}   & \multicolumn{2}{c}{Время, сек.}            & \multicolumn{2}{c}{Ошибка, \%} \\ \hline
\multicolumn{1}{l}{}   & N     & M                           & Созданный алг. & N4N алг.                  & Созданный алг.    & N4N алг.   \\ \hline
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{1288}   & 0.16           & \multicolumn{1}{c|}{0.44} & 29.0              & 43.0       \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{4905}   & 0.60           & \multicolumn{1}{c|}{1.30} & 0.0               & 0.0        \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{11153}  & 1.44           & \multicolumn{1}{c|}{1.90} & 0.0               & 0.0        \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{20201}  & 2.17           & \multicolumn{1}{c|}{2.79} & 0.0               & 0.0        \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{31187}  & 2.68           & \multicolumn{1}{c|}{2.94} & 0.0               & 0.0        \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{124658} & 8.47           & \multicolumn{1}{c|}{11.0} & 0.0               & 0.0        \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{500471} & 25.4           & \multicolumn{1}{c|}{39.3} & 0.0               & 0.0        \\ \hline
\end{tabular}
\end{table}

Из полученных результатов видно, что созданный алгоритм не уступает существующему эвристическому алгоритму. Предложенный алгоритм превосходит второй 
генетический алгоритм в несколько раз. Это во многом объясняется тем, что в алгоритме <<N4N>> используется множество для описания одной особи в популяции, 
а также при процессе мутации для вершин, которые претендуют на изменение особи, находится эксцентриситет, всех этих процессов нет в созданном алгоритме, 
поэтому его время работы меньше.
При этом видно, что алгоритм <<N4N>> на некоторых моделях случайных графов имеет меньший процент ошибки по сравнению с предложенным алгоритмом, однако 
этот процент нивелируется с увеличением размерности графа.

\conclusion
В рамках проделанной работы был предложен генетический алгоритм для поиска центральных вершин графов. Был проведен его анализ с различными классическими алгоритмами, а так же с другим генетическим алгоритмом. В ходе анализа было выявлено, что данный алгоритм имеет незначительные недостатки в точности получаемых ответов на графах малой размерности, при этом его целесообразно использовать на больших графовых моделях, где его временные затраты и процент точности оптимальны.


\bibliographystyle{gost780uv}
\bibliography{thesis}

\appendix
\section{Листинг проекта} \label{app1}
Ниже представлен код созданного класса \verb|Graph|:
\lstinputlisting{GraphWork.h}

Далее представлен код, отвечающий за работу генетических и нескольких точных алгоритмов:
\lstinputlisting{GeneticAlgorithm.h}
\lstinputlisting{OtherGA.h}

В следующем фрагменте кода приведена реализация класса для работы со случайными числами и для файлового ввода графов:
\lstinputlisting{FileWork.h}
\lstinputlisting{Random.h}

В последнем листинге приведена главная функция из которой запускался весь проект:
\lstinputlisting{main.cpp}

\section{CD с отчетом о проделанной работе}\label{app2}
На приложенном диске можно ознакомиться со следующими файлами:

\textbf{Папка} \verb|Project| "--- проект с набором тестовых графов;

\textbf{Папка} \verb|CourseWork| "--- \LaTeX вариант работы;

\verb|CourseWork3.pdf| "--- текст курсовой работы.

\end{document}
\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[english,russian]{babel}
\usepackage{booktabs}

\begin{document}

\section{Abstract}
В нашей работе представлен генетический алгоритм для поиска центральных вершин в графе, который использует иной подход к способу 
представления решения и новый взгляд на процесс кроссинговера. Полученный алгоритм сравнивался с уже существующими точными и другими 
генетическими алгоритмами на различных моделях случайных графов. Из полученных результатов можно сделать вывод о том, что 
рассматриваемый подход может использоваться в прикладных задачах и конкурировать с существующими алгоритмами.

\section{Introduction}
В теории графов нахождение радиуса графа и центральных вершин одни из важных проблем, решаемых в теоретических и практических задачах.
Рассмотрим невзвешенный нериентораванный граф $G = (V, E)$, где $|V| = n$ "--- количество вершин, $|E| = m$ "--- количество ребер. Так 
как граф невзвешенный, то длина пути между вершинами $u$ и $v$ равняется числу ребер. Для поиска центра графа используется понятие 
эксцентриситета вершины "--- расстояние от вершины до самой удаленной. На основе этого можно описать радиус графа, как 
минимальный из эксцентриситетов всех вершин. При этом вершины, на которых достигается этот минимум принято называть центральными.
Данный вопрос наиболее часто возникает при решении оптимизационных задач в компьютерных сетях и задач транспортной маршрутизации.

Эта задача хорошо изучена с точки зрения точных алгоритмов. Зачастую она рассматривается вместе с проблемой вычисления all-pairs shortes 
path in graph. Для невзвешенных графов тривиальным алгоритмом может служить запуск обхода в ширину из каждой вершины, при этом алгоритм 
имеет временную оценку $O(nm)$, что при больших $m$ равно $O(n^3)$. Все существующие алгоритмы, дающие точное решение, созданы в попытке 
улучшить данную оценку. В целом можно выделить два подхода к решению данной задачи. Первый из них предложен в работе  \cite{Seidel} и основывается на матричном умножении. На сегодняшний день существуют алгоритмы быстрого матричного умножения, 
которые дают теоретическую оценку $O(n^{2.376})$ или более применяемые на практике $O(n^{2.81})$. 

Другой подход был разработан в работе \cite{Aingworth}. В этом случае используется идея разделения вершин на множество вершин с высокой степенью 
и множество вершин с низкой степенью. 
С использованием такого подхода временную оценку удается улучшить и получить $O(m\sqrt{n})$. Данная работа дала толчок дальнейшим 
исследованиям с использованием аналогичного метода и существует ряд алгоритмов \cite{Fast_Approximation}, \cite{APSP}, \cite{Fast_Radius}, улучшающих данную оценку, в которых 
используются особые структуры данных или же предполагается низкая плотность исследуемого графа.

Данные методы могут быть широко применены на графах небольших размерностей, однако наибольший интерес для исследования представляют 
реально существующие графы, которые содержат в себе сотни тысяч вершин. Вследствие этого точные алгоритмы не могут применены для решения 
подобных задач из"=за неприемлемых временных затрат. Наиболее подходящими в данной ситуации могут быть эвристические алгоритмы, которые 
дают лучшие временные результаты, но допускают существование некого процента ошибки. 

В нашей работе мы представляем генетический алгоритм, позволяющий решать задачу поиска центральных вершин и радиуса графа. При этом в 
сравнении с некоторыми алгоритмами наш дает лучшие временные результаты.

\section{Описание алгоритма}
Генетические алгоритмы хорошо известный подход для решения оптимизационных задач. Основная идея генетического алгоритма была 
представлена Холландом \cite{Holland}. Алгоритм использует процессы генетики, которые обеспечивают эволюционное развитие живых организмов.
Согласно предложенному подходу решение представляется некоторым набором генов и основными этапами алгоритма являются процесс мутации
кроссинговера и естественного отбора. В нашем алгоритме все эти процессы реализованы с учетом рассматриваемой задачи.

Основную идею построения алгоритма можно описать следующим образом. Мы можем абстрактно изобразить граф. При этом центральные вершины
должны быть размещены в центре изображения а остальные вершины будут образовывать дискретные <<сферы>>, находящиеся на расстоянии 1, 2, 
и т.д. от центра. Используя такое представление графа, легко заметить, что для нахождения центра графа можно создать набор вершин, которые 
будут представлять <<сферу>>, внутри которой будет лежать центр. Тогда каждая итерация алгоритма должна уменьшать расстояние между 
элементами созданной <<сфера>> и стягивать её к центру. Наш алгоритм реализует это с помощью оператора кроссинговера.

\subsection{Кодирование решения}
Популяция для работы генетического алгоритма описывается одним множеством вершин, 
где каждая вершина представляет потенциальное решение.  На языке ГА это означает, что каждая особь в популяции "--- вершина графа.
В качестве начальной популяции генерируется набор случайных вершин.

\subsection{Фитнесс"=функция}
Наиболее естественным способом оценки качества полученного решения в рамках рассматриваемой задачи является значение эксцентриситета 
вершины, который находится при помощи алгоритма обхода в ширину. При этом вершины приоритет при естественном отборе отдается вершинам с меньшим эксцентриситетом.

\subsection{Мутация}
В качестве процесса мутации нами был выбран подход при котором для изменения существующей популяции с вероятностью заданной для 
оператора мутации вершина заменяется на случайную из множества ее соседей.

\subsection{Кроссинговер}
В качестве оператора кроссинговера нами использована следующая эвристика. Рассмотрим текущую популяцию, как уже описывалось ранее она 
может быть интерпретирована как окружность внутри которой лежит центр. В связи с этим можно рассмотреть пару вершин и найти между ними 
кротчайший путь с помощью поиска в ширину. После этого в качестве потомка от двух особей выбирается случайная вершина из найденного 
пути. Такой подход позволяет на каждой итерации приблизиться к некоторой вершине с оптимальным эксцентриситетом.

\section{Результаты вычислительных экспериментов}
Все алгоритмы выполнялись на компьютере AMD A8-7410 2.20 GHz and 6 GB RAM. Все алгоритмы были реализованы на языке прогарммирования С++. 

Для определения точности предложенного алгоритма был реализован точный алгоритм \cite{Aingworth}, который позволяет сделать выводы о корректности найденного решения. Также для сравнения временных затрат был взят другой генетический алгоритм, описанный в работе \cite{GA_Subset}, который имеет схожие подходы к решению рассматриваемой задачи, но отличается способом представления решения, оператором мутации и кроссинговера. Данный алгоритм использует оператор мутации, который был назван авторами N4N, поэтому далее будем так его и обозначать. 

Сравнение алгоритмов проводилось на двух моделях случайных графов. Первая из них "--- это модель Барабаши"=Альберта \cite{BA}, вторая "--- геометрический случайный граф \cite{GEOM}. Для графа БА параметр $m = 2$, а в геометрическом случайном графе $r = 0.1$. Для обоих алгоритмов производились измерения времени и точность найденных параметров. Для более четкой картины оба алгоритма запускались 100 раз на каждом тесте, что позволило получить среднее время работы и процент ошибок. 
Так как наш алгоритм использует идею абстрактного представления графа в виде сферы будем называть его <<сферическим>>. Результаты экспериментов приведены в таблице \ref{tab1} и \ref{tab2}.

\begin{table}[]
\centering
\begin{tabular}{@{}ccccc@{}}
\toprule
\multicolumn{1}{l}{№}  & \multicolumn{2}{c}{Размеры графа}  & Время работы, сек.        & Процент ошибки, \% \\ \midrule
\multicolumn{1}{l}{}   & N     & M                          &                           &                    \\ \midrule
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{996}   & \multicolumn{1}{c|}{0.07} & 16.0               \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{1996}  & \multicolumn{1}{c|}{0.18} & 12.0               \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{2996}  & \multicolumn{1}{c|}{0.37} & 4.0                \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{3996}  & \multicolumn{1}{c|}{0.55} & 1.0                \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{4996}  & \multicolumn{1}{c|}{0.69} & 0.0                \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{9996}  & \multicolumn{1}{c|}{1.84} & 0.0                \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{19996} & \multicolumn{1}{c|}{3.90} & 0.0                \\ \bottomrule
\end{tabular}
\end{table}


\begin{table}[!ht]
\centering
\caption{\label{tab2} Время работы и процент ошибки алгоритмов на геометрических графах}
\begin{tabular}{@{}ccccccc@{}}
\toprule
№                      & \multicolumn{2}{c}{Graph size}       & \multicolumn{2}{c}{Time, sec.}    & \multicolumn{2}{c}{Eroor, \%} \\ \midrule
                       & N     & M                            & Created alg.   & N4N alg.                      & Created alg.           & N4N alg.          \\ \midrule
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{3572}    & 0.11  & \multicolumn{1}{c|}{0.39} & 38.0          & 40.0           \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{14202}   & 0.31  & \multicolumn{1}{c|}{0.77} & 21.0          & 50.0           \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{31861}   & 0.71  & \multicolumn{1}{c|}{1.44} & 13.0          & 62.0           \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{57438}   & 1.20  & \multicolumn{1}{c|}{1.92} & 8.0           & 48.0           \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{90268}   & 1.76  & \multicolumn{1}{c|}{2.68} & 4.0           & 30.0           \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{358553}  & 4.48  & \multicolumn{1}{c|}{8.61} & 0.0           & 0.0            \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{1439255} & 13.54 & \multicolumn{1}{c|}{26.0} & 0.0           & 0.0            \\ \bottomrule
\end{tabular}
\end{table}


\begin{table}[]
\centering
\begin{tabular}{@{}ccccc@{}}
\toprule
\multicolumn{1}{l}{№}  & \multicolumn{2}{c}{Размеры графа}    & Время работы, сек.         & Процент ошибки, \% \\ \midrule
\multicolumn{1}{l}{}   & N     & M                            &                            &                    \\ \midrule
\multicolumn{1}{c|}{1} & 500   & \multicolumn{1}{c|}{3572}    & \multicolumn{1}{c|}{0.11}  & 38.0               \\
\multicolumn{1}{c|}{2} & 1000  & \multicolumn{1}{c|}{14202}   & \multicolumn{1}{c|}{0.31}  & 21.0               \\
\multicolumn{1}{c|}{3} & 1500  & \multicolumn{1}{c|}{31861}   & \multicolumn{1}{c|}{0.71}  & 13.0               \\
\multicolumn{1}{c|}{4} & 2000  & \multicolumn{1}{c|}{57438}   & \multicolumn{1}{c|}{1.20}  & 8.0                \\
\multicolumn{1}{c|}{5} & 2500  & \multicolumn{1}{c|}{90268}   & \multicolumn{1}{c|}{1.76}  & 4.0                \\
\multicolumn{1}{c|}{6} & 5000  & \multicolumn{1}{c|}{358553}  & \multicolumn{1}{c|}{4.48}  & 0.0                \\
\multicolumn{1}{c|}{7} & 10000 & \multicolumn{1}{c|}{1439255} & \multicolumn{1}{c|}{13.54} & 0.0                \\ \bottomrule
\end{tabular}
\end{table}

Из полученных результатов видно, что предложенный алгоритм работает в разы быстрее. При этом алгоритм дает значимый процент ошибки лишь на графах относительно малой размерности, где применять данный подход не целесообразно, так как временные затраты точных алгоритмов не значительны. Вместе с тем на с увеличением размерности графа процент неверных ответов стремится  минимуму.

\section{Заключение}
Нами был создан и реализован генетический алгоритм для решения задачи поиска центральной вершины и радиуса графа. 
Мы протестировали созданный алгоритм на двух моделях случайных графов, которые описывают большинство графов, встречающихся в реальности.
Получив эмпирические результаты можно говорить о том, что предложенный алгоритм может быть использован для решения практических задач на графах на графах большой размерности. 


\bibliographystyle{iopart-num}
\bibliography{thesis}

\end{document}

